// Generated by CoffeeScript 1.6.3
(function() {
  var GitStore, async, fs, mkdirp, pth, store, utils, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  utils = require('./utils');

  store = require('./store');

  _ = require('underscore');

  async = require('async');

  mkdirp = require('mkdirp');

  fs = require('fs');

  pth = require('path');

  /**
   * @class GitStore
   * @extends Store
  */


  GitStore = (function(_super) {
    __extends(GitStore, _super);

    function GitStore(path) {
      this.path = path;
    }

    GitStore.prototype.cmd = function(str, options, callback) {
      if (options == null) {
        options = null;
      }
      if (!callback && _.isFunction(options)) {
        callback = options;
        options = {};
      }
      options = _.extend(options, {
        cwd: this.path
      });
      return utils.cmd(str, options, callback);
    };

    GitStore.prototype.commit = function(path, message, author, cb) {
      var authorString;
      authorString = utils.sanitizeShellString(author.toString());
      return this.cmd("git commit --author=" + authorString + " -m " + message + " -- " + path, {
        env: {
          GIT_AUTHOR_NAME: author.name,
          GIT_AUTHOR_EMAIL: author.email,
          GIT_COMMITTER_NAME: author.name,
          GIT_COMMITTER_EMAIL: author.email
        }
      }, cb);
    };

    /**
    	 * Detects the presence of a repository in the present #path
    	 * @param  {Function} callback Callback to be executed upon completion
    	 * @param {Error} callback.err Error if one occurs 
    	 * @param {Boolean} callback.result true if a repository exists in this location, else false
    */


    GitStore.prototype.detect = function(callback) {
      var _this = this;
      return fs.exists(this.path, function(exists) {
        if (exists) {
          return _this.cmd('git status', function(err, stdout, stderr) {
            return callback(err, err == null);
          });
        } else {
          return callback(null, false);
        }
      });
    };

    /**
    	 * Initializes a repository
    	 * @param  {Object} options 
    	 * @param  {Function} callback 
    	 * @param {Error|null} callback.err An error, if one occurs during initialization, else null
    */


    GitStore.prototype.initialize = function(options, callback) {
      var _this = this;
      return fs.exists(this.path, function(exists) {
        if (!exists) {
          mkdirp.sync(_this.path);
        }
        return _this.cmd('git init', function(err, stdout, stderr) {
          return callback(err);
        });
      });
    };

    GitStore.prototype.create = function(path, contents, author, message, callback) {
      var dirPath,
        _this = this;
      dirPath = pth.join(this.path, pth.dirname(path));
      return mkdirp(dirPath, null, function(err, made) {
        if (err != null) {
          console.log(err);
          return callback(err);
        }
        return _this.save(path, contents, author, message, callback);
      });
    };

    /**
    	 * Saves a resource at the given path. Creates it if it does not exist
    	 * @param  {String} path Path to the resource, relative to repository root
    	 * @param  {String/Buffer} contents Contents of the resource
    	 * @param  {store.Author} author Author of the commit to be recorded
    	 * @param  {String} message Message describing the commit
    	 * 
    	 * @param  {Function} callback Callback to be executed upon completion
    	 * @param  {Error} callback.err Error if one occurs during the save
    	 * @param  {store.Resource} callback.res Resource created by the #save
    */


    GitStore.prototype.save = function(path, contents, author, message, callback) {
      var rawPath,
        _this = this;
      message = utils.sanitizeShellString(message);
      rawPath = utils.cleanPath(path);
      path = utils.sanitizePath(path);
      return async.series([
        function(cb) {
          return fs.writeFile(pth.join(_this.path, rawPath), contents, {}, cb);
        }, function(cb) {
          return _this.cmd("git add " + path, cb);
        }, function(cb) {
          return _this.commit(path, message, author, cb);
        }
      ], function(err, stdout, stdin) {
        if (err != null) {
          return callback(err);
        }
        return callback(null, new store.Resource(path, contents));
      });
    };

    /**
    	 * Reads the {@link store.Resource#contents} of a {@link store.Resource} at the given `path`
    	 * @param  {String} path Path to the resource, relative to the repository root
    	 * @param  {String} [id=null] 
    	 * Identifier of the {@link store.Revision revision} of the resource to load. If `null`, the latest revision
    	 * is loaded.
    	 * 
    	 * @param  {Function} callback Callback to be executed upon completion
    	 * @param  {Error} callback.err Error if one occurs during the read
    	 * @param {String} contents Contents of the resource
    */


    GitStore.prototype.read = function(path, id, callback) {
      var objectName;
      if (_.isFunction(id) && (callback == null)) {
        callback = id;
        id = null;
      }
      objectName = utils.sanitizeShellString(id != null ? "" + id + ":" + path : "HEAD:" + path);
      return this.cmd("git cat-file -p " + objectName, function(err, stdout, stderr) {
        if (err != null) {
          return callback(err);
        }
        return callback(null, stdout);
      });
    };

    /**
    	 * Determines if a given resource exists
    	 * @param  {String} path Path to the resource, relative to the repository root
    	 * @param {String} [id=null] Optionally an identifier to a revision of this resource
    	 * 
    	 * @param  {Function} callback Callback to be executed upon completion
    	 * @param  {Error} callback.err Error if one occurs during the read
    	 * @param {Boolean} callback.exists True if the resource/revision exists
    */


    GitStore.prototype.exists = function(path, id, callback) {
      if (id == null) {
        id = null;
      }
      if (_.isFunction(id) && (callback == null)) {
        callback = id;
        return id = null;
      }
    };

    /**
    	 * Determines the type of the resource at a given path
    	 * @param  {String} path Path to the resource, relative to the repository root
    	 * @param {String} [id=null] Optionally an identifier to a revision of this resource
    	 * 
    	 * @param  {Function} callback Callback to be executed upon completion
    	 * @param  {Error} callback.err Error if one occurs during the read
    	 * @param {Boolean} callback.type Either `'folder'` or `'file'`, or `null` if the resource does not exist.
    	 *
    */


    GitStore.prototype.type = function(path, id, callback) {
      var objectName;
      if (id == null) {
        id = null;
      }
      objectName = utils.sanitizeShellString(id != null ? "" + id + ":+" + path : "HEAD:" + path);
      return this.cmd("git cat-file -t " + objectName, function(err, stdout, stderr) {
        if (err != null) {
          return callback(null, null);
        }
        return callback(null, (function() {
          switch (stdout.trim()) {
            case "tree":
              return "folder";
            case "blob":
              return "file";
          }
        })());
      });
    };

    /**
    	 * Retrieves the metadata associated with a particular {@link store.Revision revision} of a 
    	 * {@link store.Resource resource}.
    	 * 
    	 * @param  {String} path Path to the resource, relative to the repository root
    	 * @param  {String} id Identifier of the {@link store.Revision revision} of the resource to load.
    	 * @param  {Function} callback Callback to be executed upon completion
    	 * @param  {Error} callback.err Error if one occurs during the read
    	 * @param {store.Resource} callback.res Resource object containing retrieved metadata
    */


    GitStore.prototype.retrieve = function(path, id, callback) {
      var objectName;
      objectName = utils.sanitizeShellString(id != null ? "" + id + ":+" + path : "HEAD:" + path);
      return this.cmd("git whatchanged -z --pretty='format:" + this.logFormat + "' --max-count=1 " + id, function(err, stdout, stderr) {
        if (err != null) {
          return callback(err);
        }
        return callback(null, this.parseLog(path, stdout));
      });
    };

    /**
    	 * Returns the metadata associated with the most recent revision of a resource
    	 * @param  {String} path Path to the resource, relative to the repository root
    	 * @param  {Function} callback [description]
    	 * @param  {Function} callback Callback to be executed upon completion
    	 * @param  {Error} callback.err Error if one occurs during the read
    	 * @param {store.Resource} callback.res Resource object containing retrieved metadata
    */


    GitStore.prototype.latest = function(path, callback) {
      var _this = this;
      path = utils.sanitizePath(path);
      return this.cmd("git log --pretty='format:" + this.logFormat + "' --max-count=1 HEAD -- " + path, function(err, stdout, stderr) {
        if (err != null) {
          return callback(err);
        }
        return callback(null, _this.commitRevision(path, _this.parseCommit(stdout)));
      });
    };

    GitStore.prototype.remove = function(path, callback) {
      path = utils.sanitizePath(path);
      return this.cmd("git rm " + path, callback);
    };

    GitStore.prototype.move = function(fromPath, toPath, author, message, callback) {
      var authorString;
      fromPath = utils.sanitizePath(fromPath);
      toPath = utils.sanitizePath(toPath);
      authorString = utils.sanitizeShellString(author.toString());
      return this.cmd("git mv " + fromPath + " " + toPath + " && git commit --author=" + authorString + " -m " + message, function(err, stdout, stderr) {
        return callback(err);
      });
    };

    GitStore.prototype.list = function(directory, callback) {
      var objectName;
      objectName = directory !== '/' ? utils.sanitizeShellString("HEAD:" + utils.sanitizePath(directory)) : '"HEAD"';
      return this.cmd("git ls-tree -z " + objectName, function(err, stdout, stderr) {
        var id, line, mode, path, type;
        if (err != null) {
          return callback(err);
        }
        return callback(null, (function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = stdout.split('\x00');
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            line = _ref[_i];
            if (!(line)) {
              continue;
            }
            _ref1 = line.match(/\d{6} (blob|tree) (\w{40})\t([@\w\. ]+)/), mode = _ref1[0], type = _ref1[1], id = _ref1[2], path = _ref1[3];
            if (type === 'tree') {
              path += '/';
            }
            _results.push(new store.Resource(pth.join(directory, path)));
          }
          return _results;
        })());
      });
    };

    GitStore.prototype.search = function(pattern, options, callback) {
      var args;
      args = [];
      if (options.ignoreCase) {
        args.push('--ignore-case');
      }
      if (options.wordRegexp) {
        args.push('--word-regexp');
      }
      if (options.allMatch) {
        args.push('--all-match');
      }
      pattern = utils.sanitizeShellString(pattern);
      return this.cmd("git grep -I -n " + (args.join(' ')) + " -e " + pattern, function(err, stdout, stderr) {
        var all, line, match, path;
        if (err != null) {
          return callback(err);
        }
        return callback(err, (function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = stdout.split('\n');
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            line = _ref[_i];
            if (!(line)) {
              continue;
            }
            _ref1 = line.match(/([\w\.\\/\\]+):(\d+):(.+)/), all = _ref1[0], path = _ref1[1], line = _ref1[2], match = _ref1[3];
            _results.push([new store.Resource(path), line, match]);
          }
          return _results;
        })());
      });
    };

    /**
    	 * Retrieves a list of revisions associated with the particular resource
    	 * @param  {String} path Path to the resource, relative to the repository root
    	 * 
    	 * @param  {Object} [options=null] Hash of options 
    	 * @param {Date} [options.since=null] Select changes after this particular date
    	 * @param {Date} [options.until=null] Select changes before this particular date
    	 * @param {Number} [options.limit=null] Select only this number of changes
    	 * 
    	 * @param  {Function} callback Callback to be executed upon completion
    	 * @param  {Error} callback.err Error if one occurs during the read
    	 * @param {store.Revision[]} callback.revisions Array of revisions
    */


    GitStore.prototype.log = function(path, options, callback) {
      var args,
        _this = this;
      if (options == null) {
        options = null;
      }
      if ((callback == null) && _.isFunction(options)) {
        callback = options;
        options = {};
      }
      path = utils.sanitizePath(path);
      args = [];
      if (options.since) {
        args.push("--since=" + utils.sanitizeShellString(options.since));
      }
      if (options.until) {
        args.push("--until=" + utils.sanitizeShellString(options.until));
      }
      if (options.limit) {
        args.push("-n " + utils.sanitizeShellString(options.until));
      }
      return this.cmd("git whatchanged --name-only --pretty='format:" + this.logFormat + "' -- " + path, function(err, stdout, stderr) {
        var revs;
        if (err != null) {
          return callback(err);
        }
        revs = _this.parseLogLines(stdout);
        return callback(null, revs);
      });
    };

    /**
    	 * @private
    	 * @param  {String} text Input lines from `git whatchanged`
    	 * @return {store.Revision[]} Generated revisions
    */


    GitStore.prototype.parseLogLines = function(text) {
      var commit, line, revs, s;
      revs = [];
      commit = null;
      revs = (function() {
        var _i, _len, _ref, _results;
        _ref = text.split('\n');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          if (line) {
            if (this.commitPattern.test(line)) {
              commit = this.parseCommit(line);
              _results.push(null);
            } else {
              _results.push(this.commitRevision(line, commit));
            }
          }
        }
        return _results;
      }).call(this);
      revs = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = revs.length; _i < _len; _i++) {
          s = revs[_i];
          if (s) {
            _results.push(s);
          }
        }
        return _results;
      })();
      return revs;
    };

    /**
    	 * Format git should use to output commit messages
    	 * @private
    	 * @type {String}
    */


    GitStore.prototype.logFormat = '%H%x00%an%x00%ae%x00%ct%x00%B';

    /**
    	 * Regular expression to parse commit messages
    	 * @private
    	 * @type {RegExp}
    */


    GitStore.prototype.commitPattern = /(\w+)\0([\w\s]+)\0([\w\s\.@]+)\0(\d+)\0(.*)/;

    /**
    	 * Parses a commit message encoded using the #logFormat
    	 * @private
    	 * @param  {String} line A line of output from a git-log like function with format {@link #logFormat}
    */


    GitStore.prototype.parseCommit = function(line) {
      var match;
      match = line.match(this.commitPattern);
      if (match) {
        match[4] = new Date(parseInt(match[4]) * 1000);
        return match.slice(1);
      } else {
        return null;
      }
    };

    /**
    	 * Generates a revision from a path and a {@link #parseCommit parsed commit statement}
    	 * @private
    	 * @param  {String} path Path to the relevant resource
    	 * @param  {Array} commit Parsed commit string (see #parseCommit)
    	 * @return {store.Revision} Revision
    */


    GitStore.prototype.commitRevision = function(path, commit) {
      var authorEmail, authorName, id, message, time;
      if (commit) {
        id = commit[0], authorName = commit[1], authorEmail = commit[2], time = commit[3], message = commit[4];
        return new store.Revision(path, id, time, new store.Author(authorName, authorEmail), message, []);
      }
    };

    return GitStore;

  })(store.Store);

  module.exports = {
    GitStore: GitStore
  };

}).call(this);
